articlemaster

Catalog manager

Package implements a Catalog Manager which exposes Rest Apis for the Article/Item Management. It relies on Package gorilla/mux to manage routes and handle routing. The name mux stands for "HTTP request multiplexer". Like the standard http.ServeMux, mux.Router matches incoming requests against a list of registered routes and calls a handler for the route that matches the URL or other conditions.The main features of the Catalog manager are:
•Exposes the Rest Apis for Creating and Retrieving articles.
•Exposes the Rest Apis for Tag Creation and Look up.
•It is scalable and runs each HTTP Request in its own Go_Routine.
•Employes Map based Indexes for efficient look up in the Data Storage.
•Is thread safe and employes locking to ensure the data integrity.
•The Data Repository is pluggable and could handle multiple database types.

installation
1.Install the Go lang runtime on the local machine.
2.Create the path on the local machine at $GOPATH/src/github.com/gokoder.
3.Change into articlemaster and Run go get github.com/gokoder/articlemaster.
4.Run go run main.go.

assumptions
1.The package relies on in memory storage.
2.The Catalog Manager only implements the oprations Read,Update and Create and leaves rest of the operations.
3.Throws back the errors encountered to the front end as JSON Messages.

implementation details

•The errors encountered on the backend are thrown from the REST Endpoints as JSON Messages with appropriate HTTP Error codes.


•The article ids are autogenerated within the implementation.


•The package relies on a mix of OOB Go Unit Testing and Postman for testing the solution.


•The implementation relies on dictionaries to store the articles and tags.


•The GoLang stack was chosen from the following:
i.NodeJS
ii.Java/SpringBoot
iii.GoLang/Gorilla Mux

The following are the considered factors: The NodeJS stack is more suitable for business processes which are I/O bound. The NodeJS Event Loop is not meant to run longer
 computations. The Java/SpringBoot based services are heavy weight and have much larger memory footprint. They have much higher boot time and are not preferable for web scale applications. The Java's model of 1 thread per request fails for web scale applications as thread context switches take most of the time/memory. The Golang services are light weight and offer rich support for concurrency via go routines and channels. The go routines are light weight and offer rich support for parellelism.

Sample Inputs/Outputs POST /articles { "title": "latest science shows that potato chips are better for you than sugar", "date" : "2016-09-28", "body" : "some text, potentially containing simple markup about how potato chips are great", "tags" : ["health", "fitness", "science"] } {"CodeInt":1,"CodeString":"","CodeDescription":"Success"}

GET articles/1 "{"id":"4","title":"latest science shows that potato chips are better for you than sugar","body":"some text, potentially containing simple markup about how potato chips are great","tags":["health","fitness","science"],"date":"2016-09-28"}"

PUT articles/1 { "title": "latest science shows that potato chips are better for you than sugar", "date" : "2016-09-22", "body" : "some text, potentially containing simple markup about how potato chips are great", "tags" : ["health", "fitness", "science"] } {"CodeInt":1,"CodeString":"","CodeDescription":"Success"}

GET tags/fitness/20160922 "{"tag":"fitness","count":3,"articles":[4,6,7],"related_tags":["health","fitness","science"]}"


improvements
•Implement more Apis to offer all the CRUD Operations and Data Query Operations.
•Use a much more robust approach for id generation.
•Minimize explicit locking.
•Offer connectors to various databases such as mongodb.
•Implement better map based indexes to offer faster lookup performance. We are running loops at this moment.
•Use a build tool such as dep. The package uses go get for now.
